using DotnetCombine.Model;
using DotnetCombine.Options;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DotnetCombine.Services
{
    public class Combiner
    {
        public const string OutputExtension = ".cs";
        private CombineOptions _options = null!;

        public async Task<int> Run(CombineOptions options)
        {
            options.Validate();
            try
            {
                _options = options;
                await Combine();
            }
            catch (Exception e)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine(e.Message);
                return 1;
            }
            finally
            {
                Console.ResetColor();
            }

            return 0;
        }

        private async Task Combine()
        {
            var filePaths = FindFilesToInclude();
            var outputFilePath = GetOutputFilePath();
            var parsedFiles = await ParseFiles(filePaths);

            var includeSection = string.Concat(parsedFiles.SelectMany(p => p.Usings).Distinct().OrderBy(_ => _));

            var codeSection = new StringBuilder();

            foreach (var parsedFile in parsedFiles)
            {
                codeSection.Append(Environment.NewLine);
                codeSection.Append(string.Join(Environment.NewLine, parsedFile.Code));
                codeSection.Append(Environment.NewLine);
            }

            using var fs = new FileStream(outputFilePath, _options.OverWrite ? FileMode.Create : FileMode.CreateNew);
            using var sw = new StreamWriter(fs);
            await sw.WriteLineAsync($"// File generated by dotnet-combine at {DateTime.Now.ToLocalTime().ToString(UniqueIdGenerator.DateFormat)}");
            await sw.WriteAsync(includeSection);
            await sw.WriteAsync(Environment.NewLine);
            await sw.WriteAsync(Environment.NewLine);
            await sw.WriteAsync(codeSection);
        }

        private string GetOutputFilePath()
        {
            string composeFileName(string fileNameWithoutExtension) =>
                (_options.Prefix ?? string.Empty) +
                fileNameWithoutExtension +
                (_options.Suffix ?? string.Empty) +
                OutputExtension;

            string fileName = composeFileName(UniqueIdGenerator.UniqueId());
            string basePath = Path.TrimEndingDirectorySeparator(_options.Input);

            if (_options.Output is not null)
            {
                if (Path.EndsInDirectorySeparator(_options.Output))
                {
                    basePath = _options.Output.ReplaceEndingDirectorySeparatorWithProperEndingDirectorySeparator();
                    Directory.CreateDirectory(basePath);
                }
                else
                {
                    var directoryName = Path.GetDirectoryName(_options.Output);

                    basePath = string.IsNullOrEmpty(directoryName)
                        ? _options.Input + Path.DirectorySeparatorChar
                        : Directory.CreateDirectory(directoryName).FullName;

                    fileName = composeFileName(Path.GetFileNameWithoutExtension(_options.Output));
                }
            }

            return Path.Combine(basePath, fileName);
        }

        private ICollection<string> FindFilesToInclude()
        {
            if (!Directory.Exists(_options.Input))
            {
                return File.Exists(_options.Input)
                    ? new List<string> { _options.Input }
                    : new List<string>();
            }

            var filesToExclude = _options.ExcludedItems.Where(item => !Path.EndsInDirectorySeparator(item));

            var dirsToExclude = _options.ExcludedItems
                .Except(filesToExclude)
                .Select(dir => Path.DirectorySeparatorChar + dir.ReplaceEndingDirectorySeparatorWithProperEndingDirectorySeparator());

            return Directory.GetFiles(_options.Input, $"*{OutputExtension}", SearchOption.AllDirectories)
                .Where(filePath => dirsToExclude?.Any(exclusion => $"{Path.GetDirectoryName(filePath)}{Path.DirectorySeparatorChar}"?.Contains(exclusion, StringComparison.OrdinalIgnoreCase) == true) == false
                && filesToExclude?.Any(exclusion => string.Equals(Path.GetFileName(filePath), exclusion, StringComparison.OrdinalIgnoreCase)) == false)
                .ToList();
        }

        private async Task<ICollection<SourceFile>> ParseFiles(ICollection<string> filePaths)
        {
            var tasks = filePaths.Select(async filePath =>
            {
                var parsedFile = new SourceFile(filePath);
                await parsedFile.Parse(_options);
                return parsedFile;
            });

            return (await Task.WhenAll(tasks)).ToList();
        }
    }
}
